<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<meta name="viewport" content="width=device-width,height=device-height, user-scalable=no"/>
	<title>Leaflet.Editable demo</title>
	<link rel="stylesheet" href="https://npmcdn.com/leaflet@1.3.4/dist/leaflet.css"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
	<script src="https://npmcdn.com/leaflet@1.3.4/dist/leaflet.js"></script>
	<script src="https://npmcdn.com/leaflet.path.drag/src/Path.Drag.js"></script>
	<script src="../lib/Leaflet.Editable.js"></script>

	<style type='text/css'>
		body { margin: 0; padding: 0; }

		/*#map { position: absolute; top: 0; bottom: 0; right: 0; left: 0; width: 100%; }*/
	</style>
</head>
<body>
<form class="form-inline">
	<button type="button" class="form-control" onclick="subDivide()">Subdivide plots</button>
</form>
<div id="map_controls" style="width: 980px"></div>
<div id="map" style="width: 980px; height: 600px"></div>

<script type="text/javascript">
	var startPoint = [42.464292, -76.451431];
	// var map = L.map('map', {editable: true}).setView(startPoint, 16),
	// 	tilelayer = L.tileLayer('http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {maxZoom: 20, attribution: 'Data \u00a9 <a href="http://www.openstreetmap.org/copyright"> OpenStreetMap Contributors </a> Tiles \u00a9 HOT'}).addTo(map);

	// Set up Leaflet Map
	var map = L.map('map', {editable: true}).setView(startPoint, 16);

	// Add Map Layer
	var tilelayer = L.tileLayer('http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}?blankTile=false', {
		attribution: '&copy; <a href="http://www.esri.com/">Esri</a>, DigitalGlobe, GeoEye, i-cubed, USDA FSA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',
		maxZoom: 28,
		maxNativeZoom: 19
	}).addTo(this.map);

	L.EditControl = L.Control.extend({

		options: {
			position: 'topleft',
			callback: null,
			kind: '',
			html: ''
		},

		onAdd: function (map) {
			var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
				link = L.DomUtil.create('a', '', container);

			link.href = '#';
			link.title = 'Create a new ' + this.options.kind;
			link.innerHTML = this.options.html;
			L.DomEvent.on(link, 'click', L.DomEvent.stop)
				.on(link, 'click', function () {
					window.LAYER = this.options.callback.call(map.editTools);
				}, this);

			return container;
		}

	});

	// L.NewLineControl = L.EditControl.extend({
	//
	// 	options: {
	// 		position: 'topleft',
	// 		callback: map.editTools.startPolyline,
	// 		kind: 'line',
	// 		html: '\\/\\'
	// 	}
	//
	// });

	var polygon = L.polygon([
		[
			[42.467048, -76.457162],
			[42.464895, -76.457055],
			[42.464974, -76.449394],
			[42.463771, -76.44933],
			[42.463866, -76.445789],
			[42.467317, -76.448407],
			[42.467317, -76.44918],
			[42.467048, -76.457162]
		]
	]);
	polygon.addTo(map).enableEdit();

	L.NewPolygonControl = L.EditControl.extend({

		options: {
			position: 'topleft',
			callback: function () {
				polygon = map.editTools.startPolygon();
				return polygon;
			},
			kind: 'polygon',
			html: 'â–°'
		}

	});


	L.NewMarkerControl = L.EditControl.extend({

		options: {
			position: 'topleft',
			callback: map.editTools.startMarker,
			kind: 'marker',
			html: 'ðŸ–ˆ'
		}

	});

	// polygon = L.rectangle([
	// 	[
	// 		[42.467111, -76.449802],
	// 		[42.467111, -76.457312],
	// 		[42.465053, -76.457312],
	// 		[42.465053, -76.449802],
	// 		[42.467111, -76.449802]
	// 	]
	// ]);
	// polygon.addTo(map).enableEdit();

	L.NewRectangleControl = L.EditControl.extend({

		options: {
			position: 'topleft',
			callback: function () {
				polygon = map.editTools.startRectangle();
				return polygon;
			},
			kind: 'rectangle',
			html: 'â¬›'
		}

	});

	map.addControl(new L.NewMarkerControl());
	// map.addControl(new L.NewLineControl());
	map.addControl(new L.NewPolygonControl());
	map.addControl(new L.NewRectangleControl());

	function featureToL(feature) {
		return turf.getCoords(turf.flip(feature));
	}

	var geoJSON;

	function subDivide(event) {
		// map.eachLayer(function (layer) {
		// 	console.log(layer.toGeoJSON())
		// });
		geoJSON = polygon.toGeoJSON();
		// let geoJSON = polygon.toGeoJSON();
		if (!geoJSON) return;
		// console.log(geoJSON, turf.envelope(geoJSON))
		// L.geoJSON(turf.hexGrid(turf.bbox(geoJSON), 0.05)).addTo(map);
		// L.geoJSON(turf.squareGrid(turf.bbox(geoJSON), 0.05, {mask: geoJSON})).addTo(map);
		// L.geoJSON(turf.tesselate(geoJSON)).addTo(map);
		// L.rectangle(turf.envelope(geoJSON)).addTo(map);
		// L.rectangle(turf.bbox(geoJSON)).addTo(map);
		// console.log(turf.bbox(geoJSON))
		// L.geoJSON(turf.bboxPolygon((turf.bbox(geoJSON)))).addTo(map)
		// grid = L.geoJSON(turf.squareGrid(turf.bbox(geoJSON), 0.05, {mask: geoJSON})).addTo(map);

		// var points = turf.exploded(geoJSON)
		// grid = L.geoJSON(turf.pointOnFeature(turf.rec(turf.bbox(geoJSON), 0.05, {mask: geoJSON}))).addTo(map)

		// var squareGrid = turf.squareGrid(turf.bbox(geoJSON), 0.05);
		// // var squareGrid = turf.squareGrid(turf.bbox(geoJSON), 0.05);
		// let join = false;
		// turf.featureEach(squareGrid, function (currentFeature, featureIndex) {
		// 	// currentFeature.properties.even = featureIndex % 2 === 0;
		// 	currentFeature.properties.join = (join = !join);
		// });
		// // grid = L.geoJSON(turf.dissolve(squareGrid, { propertyName: 'even'})).addTo(map);
		// let dissolve = turf.dissolve(squareGrid, { propertyName: 'join'});
		// turf.featureEach(dissolve, function (currentFeature) {
		// 	L.rectangle(turf.getCoords(turf.flip(currentFeature))).addTo(map)
		// 		.enableEdit();
		// });

		// let bbox = turf.bbox(geoJSON);
		// var squareGrid = turf.squareGrid(bbox,0.1, {mask: geoJSON});
		// var centroids = turf.featureCollection(squareGrid.features.map((feature)=>{
		// 	return turf.centroid(feature);
		// }));
		// grid = L.geoJSON(turf.voronoi(centroids,{bbox:bbox}).features.map((feature)=>{
		// 	return turf.intersect(feature,geoJSON);
		// })).addTo(map);

		// let bbox = turf.bbox(geoJSON);
		// var squareGrid = turf.squareGrid(bbox,0.02/*, {mask: geoJSON}*/);
		// let group = 0,
		// 	count = 1,
		// 	plotSize = 50;
		// turf.featureEach(squareGrid, function (currentFeature, featureIndex) {
		// 	currentFeature.properties.join = "group"+group;
		// 	if (count++===plotSize) {
		// 		count = 1;
		// 		group++;
		// 	}
		// });
		// let dissolve = turf.dissolve(squareGrid, {propertyName: 'join'})
		// grid = L.geoJSON(dissolve).addTo(map);

		// let bbox = turf.bbox(geoJSON);
		// var squareGrid = turf.squareGrid(bbox,0.1, {mask: geoJSON});
		// var pointGrid = turf.pointGrid(bbox,0.1, {mask: geoJSON});
		// var centroids = turf.featureCollection(squareGrid.features.map((feature)=>{
		// 	return turf.intersect(feature,geoJSON)
		// }).map((feature)=>{
		// 	return turf.centroid(feature);
		// }));
		// grid = L.geoJSON(centroids).addTo(map);
		// grid = L.geoJSON(squareGrid).addTo(map);

		// let rows = 2,
		// 	cols = 1,
		// 	plotFactor = 2; // length / width
		// let plotNumber = rows*cols,
		// 	plotArea = turf.area(geoJSON)/plotNumber, // square meters
		// 	plotWidth = Math.sqrt(plotArea/plotFactor), // width * length = area => width * (width*factor) = area => width = sqrt(area/factor)
		// 	plotLength = plotArea/plotWidth;

		// let perimeter = turf.polygonToLine(geoJSON);
		// turf.lineChunk(perimeter, turf.length(perimeter)/plotNumber).features.forEach((feature)=>{
		// 	L.polyline(featureToL(feature)).addTo(map).enableEdit()
		// })

		function getPlots(polygon, levels, level) {
			let centers = [];
			let points = turf.explode(turf.bboxPolygon(turf.bbox(polygon)));
			let center = turf.center(points);
			Array.prototype.push.apply(centers, points.features.map(vertex => {
				return turf.center(turf.featureCollection([vertex, center]))
			}));
			let bbox = turf.bbox(polygon);
			let plots = turf.voronoi(turf.featureCollection(centers), {bbox: bbox})
				.features
				.filter(x => x)
				.map(feature=>turf.intersect(feature,polygon))
			if (level < levels) {
				level++;
				let subPlots = [];
				plots.forEach(plot=>{
					subPlots.push(...getPlots(plot, levels, level));
				});
				return subPlots;
			}
			return plots;
		}
		let levels = 3,
			level = 1;
		let plots = getPlots(geoJSON, levels, level);
		plots.filter(x=>x).forEach(plot=>{
			L.polygon(featureToL(plot)).addTo(map).enableEdit()
		})

	}
	subDivide();

	function log(feature) {
		L.geoJSON(feature).addTo(map)
		return feature;
	}

</script>
</body>
</html>
