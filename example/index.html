<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width,height=device-height, user-scalable=no"/>
  <title>BrAPI Fieldmap</title>
  <link rel="stylesheet" href="https://npmcdn.com/leaflet@1.3.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
  <script src="https://npmcdn.com/leaflet@1.3.4/dist/leaflet.js"></script>
  <script src="https://npmcdn.com/leaflet.path.drag/src/Path.Drag.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="../lib/Leaflet.Editable.js"></script>

  <style type='text/css'>
    body { margin: 0; padding: 0; }

    /*#map { position: absolute; top: 0; bottom: 0; right: 0; left: 0; width: 100%; }*/
  </style>
</head>
<body style="padding:2em;">
<h1>
  BrAPI Fieldmap
</h1>
<div class="forward-container">
  <form class="form-inline" style="padding:10px;">
    <div class="form-group">
      <label for="endpoint">BrAPI Base URL</label> <input type="text" class="form-control" name="endpoint" value="https://cassavabase.org/brapi/v1">
    </div>
  </form>
  <form class="form-inline" style="padding:10px;">
    <div class="form-group">
      <label for="rows">rows</label>
      <input type="text" class="form-control" id="rows" name="rows" value="2">
    </div>
    <div class="form-group">
      <label for="cols">cols</label>
      <input type="text" class="form-control" id="cols" name="cols" value="4">
    </div>
    <a class="btn btn-default" onclick="subDivide()">Subdivide</a>
  </form>
  <br>
</div>
<div class="brapp-container" style="position:relative;">
  <div value="brapp-wrapper" style="display:inline-block; border:solid 1px #ccc;border-radius:4px;">
    <div class="brapp-body" style="background-color:#fff;border-top-left-radius:4px;border-top-right-radius:4px;">
      <div id="map_controls" style="width: 980px"></div>
      <div id="map" style="width: 980px; height: 600px"></div>
      <div style="clear:both"></div>
    </div>
    <div class="brapp-footer" style="background-color:#ddd;border-top:solid 1px #ccc;font-family:Arial;color:#555;font-size:11px;padding:0.3em;border-bottom-left-radius:4px;border-bottom-right-radius:4px;">
      <div style="min-height:14px;text-align:right;">
        <a href="https://github.com/solgenomics/BrAPI-Fieldmap" style="color:inherit;white-space:nowrap;text-decoration:underline;">BrAPI Fieldmap</a> developed at the <a href="https://btiscience.org/" style="color:inherit;white-space:nowrap;text-decoration:underline;">Boyce Thompson Institute</a>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">
  var startPoint = [42.464292, -76.451431];
  // var map = L.map('map', {editable: true}).setView(startPoint, 16),
  // 	tilelayer = L.tileLayer('http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {maxZoom: 20, attribution: 'Data \u00a9 <a href="http://www.openstreetmap.org/copyright"> OpenStreetMap Contributors </a> Tiles \u00a9 HOT'}).addTo(map);

  // Set up Leaflet Map
  var map = L.map('map', {editable: true}).setView(startPoint, 16);
  map.scrollWheelZoom.disable();

  // Add Map Layer
  // var tilelayer = L.tileLayer('http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}?blankTile=false', {
  // 	attribution: '&copy; <a href="http://www.esri.com/">Esri</a>, DigitalGlobe, GeoEye, i-cubed, USDA FSA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',
  // 	maxZoom: 28,
  // 	maxNativeZoom: 19
  // }).addTo(this.map);

  L.EditControl = L.Control.extend({

    options: {
      position: 'topleft',
      callback: null,
      kind: '',
      html: ''
    },

    onAdd: function (map) {
      var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
        link = L.DomUtil.create('a', '', container);

      link.href = '#';
      link.title = 'Create a new ' + this.options.kind;
      link.innerHTML = this.options.html;
      L.DomEvent.on(link, 'click', L.DomEvent.stop)
        .on(link, 'click', function () {
          window.LAYER = this.options.callback.call(map.editTools);
        }, this);

      return container;
    }

  });

  // L.NewLineControl = L.EditControl.extend({
  //
  // 	options: {
  // 		position: 'topleft',
  // 		callback: map.editTools.startPolyline,
  // 		kind: 'line',
  // 		html: '\\/\\'
  // 	}
  //
  // });

  var polygon = L.polygon([
    [
      [42.467048, -76.457162],
      [42.464895, -76.457055],
      [42.464974, -76.449394],
      [42.463771, -76.44933],
      [42.463866, -76.445789],
      [42.467317, -76.448407],
      [42.467317, -76.44918],
      [42.467048, -76.457162]
    ]
  ]);
  // polygon.addTo(map).enableEdit();

  L.NewPolygonControl = L.EditControl.extend({

    options: {
      position: 'topleft',
      callback: function () {
        polygon = map.editTools.startPolygon();
        return polygon;
      },
      kind: 'polygon',
      html: 'â–°'
    }

  });


  L.NewMarkerControl = L.EditControl.extend({

    options: {
      position: 'topleft',
      callback: map.editTools.startMarker,
      kind: 'marker',
      html: 'ðŸ–ˆ'
    }

  });

  polygon = L.rectangle([
    [
      [42.467111, -76.449802],
      [42.467111, -76.457312],
      [42.465053, -76.457312],
      [42.465053, -76.449802],
      [42.467111, -76.449802]
    ]
  ]);
  polygon.addTo(map).enableEdit();

  L.NewRectangleControl = L.EditControl.extend({

    options: {
      position: 'topleft',
      callback: function () {
        polygon = map.editTools.startRectangle();
        return polygon;
      },
      kind: 'rectangle',
      html: 'â¬›'
    }

  });

  map.addControl(new L.NewMarkerControl());
  // map.addControl(new L.NewLineControl());
  map.addControl(new L.NewPolygonControl());
  map.addControl(new L.NewRectangleControl());

  function featureToL(feature) {
    return turf.getCoords(turf.flip(feature));
  }

  var geoJSON;

  function subDivide(event) {
    // map.eachLayer(function (layer) {
    // 	console.log(layer.toGeoJSON())
    // });
    geoJSON = polygon.toGeoJSON();
    // let geoJSON = polygon.toGeoJSON();
    if (!geoJSON) return;
    // console.log(geoJSON, turf.envelope(geoJSON))
    // L.geoJSON(turf.hexGrid(turf.bbox(geoJSON), 0.05)).addTo(map);
    // L.geoJSON(turf.squareGrid(turf.bbox(geoJSON), 0.05, {mask: geoJSON})).addTo(map);
    // L.geoJSON(turf.tesselate(geoJSON)).addTo(map);
    // L.rectangle(turf.envelope(geoJSON)).addTo(map);
    // L.rectangle(turf.bbox(geoJSON)).addTo(map);
    // console.log(turf.bbox(geoJSON))
    // L.geoJSON(turf.bboxPolygon((turf.bbox(geoJSON)))).addTo(map)
    // grid = L.geoJSON(turf.squareGrid(turf.bbox(geoJSON), 0.05, {mask: geoJSON})).addTo(map);

    // var points = turf.exploded(geoJSON)
    // grid = L.geoJSON(turf.pointOnFeature(turf.rec(turf.bbox(geoJSON), 0.05, {mask: geoJSON}))).addTo(map)

    // var squareGrid = turf.squareGrid(turf.bbox(geoJSON), 0.05);
    // // var squareGrid = turf.squareGrid(turf.bbox(geoJSON), 0.05);
    // let join = false;
    // turf.featureEach(squareGrid, function (currentFeature, featureIndex) {
    // 	// currentFeature.properties.even = featureIndex % 2 === 0;
    // 	currentFeature.properties.join = (join = !join);
    // });
    // // grid = L.geoJSON(turf.dissolve(squareGrid, { propertyName: 'even'})).addTo(map);
    // let dissolve = turf.dissolve(squareGrid, { propertyName: 'join'});
    // turf.featureEach(dissolve, function (currentFeature) {
    // 	L.rectangle(turf.getCoords(turf.flip(currentFeature))).addTo(map)
    // 		.enableEdit();
    // });

    // let bbox = turf.bbox(geoJSON);
    // var squareGrid = turf.squareGrid(bbox,0.1, {mask: geoJSON});
    // var centroids = turf.featureCollection(squareGrid.features.map((feature)=>{
    // 	return turf.centroid(feature);
    // }));
    // grid = L.geoJSON(turf.voronoi(centroids,{bbox:bbox}).features.map((feature)=>{
    // 	return turf.intersect(feature,geoJSON);
    // })).addTo(map);

    // let bbox = turf.bbox(geoJSON);
    // var squareGrid = turf.squareGrid(bbox,0.02/*, {mask: geoJSON}*/);
    // let group = 0,
    // 	count = 1,
    // 	plotSize = 50;
    // turf.featureEach(squareGrid, function (currentFeature, featureIndex) {
    // 	currentFeature.properties.join = "group"+group;
    // 	if (count++===plotSize) {
    // 		count = 1;
    // 		group++;
    // 	}
    // });
    // let dissolve = turf.dissolve(squareGrid, {propertyName: 'join'})
    // grid = L.geoJSON(dissolve).addTo(map);

    // let bbox = turf.bbox(geoJSON);
    // var squareGrid = turf.squareGrid(bbox,0.1, {mask: geoJSON});
    // var pointGrid = turf.pointGrid(bbox,0.1, {mask: geoJSON});
    // var centroids = turf.featureCollection(squareGrid.features.map((feature)=>{
    // 	return turf.intersect(feature,geoJSON)
    // }).map((feature)=>{
    // 	return turf.centroid(feature);
    // }));
    // grid = L.geoJSON(centroids).addTo(map);
    // grid = L.geoJSON(squareGrid).addTo(map);

    // let perimeter = turf.polygonToLine(geoJSON);
    // turf.lineChunk(perimeter, turf.length(perimeter)/plotNumber).features.forEach((feature)=>{
    // 	L.polyline(featureToL(feature)).addTo(map).enableEdit()
    // })

    // Subdivide algorithm

    // function getPlots(polygon, levels, level) {
    // 	let centers = [];
    // 	let points = turf.explode(turf.bboxPolygon(turf.bbox(polygon)));
    // 	let center = turf.center(points);
    // 	Array.prototype.push.apply(centers, points.features.map(vertex => {
    // 		return turf.center(turf.featureCollection([vertex, center]))
    // 	}));
    // 	let bbox = turf.bbox(polygon);
    // 	let plots = turf.voronoi(turf.featureCollection(centers), {bbox: bbox})
    // 		.features
    // 		.filter(x => x)
    // 		.map(feature=>turf.intersect(feature,polygon));
    // 	if (level < levels) {
    // 		level++;
    // 		let subPlots = [];
    // 		plots.forEach(plot=>{
    // 			subPlots.push(...getPlots(plot, levels, level));
    // 		});
    // 		return subPlots;
    // 	}
    // 	return plots;
    // }
    // let levels = 3,
    // 	level = 1;
    // let plots = getPlots(geoJSON, levels, level);
    // plots.filter(x=>x).forEach(plot=>{
    // 	L.rectangle(featureToL(turf.transformScale(plot, 0.85))).addTo(map).enableEdit()
    // });
    // polygon.remove();

    // Cluster algorithm

    // let rows = 2,
    // 	cols = 4,
    // 	plotFactor = 2; // length / width
    // let plotNumber = rows*cols,
    // 	plotArea = turf.area(geoJSON)/plotNumber, // square meters
    // 	plotWidth = Math.sqrt(plotArea/plotFactor), // width * length = area => width * (width*factor) = area => width = sqrt(area/factor)
    // 	plotLength = plotArea/plotWidth;
    // var cellSide = plotLength/1000;
    // let geo = turf.pointGrid(turf.bbox(geoJSON), cellSide/*, {mask: geoJSON}*/);
    // geo = turf.clustersKmeans(geo, {numberOfClusters:plotNumber})
    // let centers = [];
    // turf.clusterEach(geo, 'cluster', (cluster)=>{
    // 	centers.push(turf.center(cluster));
    // });
    // geo = turf.featureCollection(centers);
    // geo = turf.featureCollection(turf.voronoi(geo, {bbox: turf.bbox(geoJSON)}).features.map((feature)=>{
    // 	return turf.intersect(feature, geoJSON)
    // }));
    // L.geoJSON(geo).addTo(map)

    // let rows = 2,
    // 	cols = 4,
    // 	plotFactor = 2; // length / width
    // let plotNumber = rows*cols,
    // 	plotArea = turf.area(geoJSON)/plotNumber, // square meters
    // 	plotWidth = Math.sqrt(plotArea/plotFactor), // width * length = area => width * (width*factor) = area => width = sqrt(area/factor)
    // 	plotLength = plotArea/plotWidth;
    // var cellSide = plotLength/1000;
    // let bbox = turf.bbox(geoJSON);
    // // let rowPoints = turf.lineString([[bbox[0], bbox[1]], [bbox[0], bbox[3]]])
    // // rowPoints = turf.lineChunk(rowPoints, turf.length(rowPoints)/rows)
    // // rowPoints = turf.explode(rowPoints)
    // // L.geoJSON(rowPoints).addTo(map)
    // let colPoints = turf.lineString([[bbox[0], bbox[3]], [bbox[2], bbox[3]]])
    // colPoints = turf.lineChunk(colPoints, turf.length(colPoints)/cols)
    // colPoints = turf.explode(colPoints)
    // L.geoJSON(colPoints).addTo(map)

    // Row / Col algorithm

    let bbox = turf.bbox(geoJSON);
    let rows = d3.select("#rows").node().value,
      cols = d3.select("#cols").node().value,
      plotWidth = (bbox[3] - bbox[1]) / rows,
      plotLength = (bbox[2] - bbox[0]) / cols;
    let points = [];
    for (let i=0; i<rows; i++) {
      for (let j=0; j<cols; j++) {
        points.push(turf.point([bbox[0]+plotLength/2+j*plotLength, bbox[1]+plotWidth/2+i*plotWidth]));
      }
    }
    let geo = turf.voronoi(turf.featureCollection(points), {bbox: turf.bbox(geoJSON)})
      .features.map((plot) => turf.intersect(plot, geoJSON));
    geo.forEach(plot => {
      L.polygon(featureToL(turf.transformScale(plot, 0.85))).addTo(map).enableEdit()
    });
    polygon.remove();

  }

  subDivide();

  function log(feature) {
    L.geoJSON(feature).addTo(map)
    return feature;
  }

</script>
</body>
</html>
